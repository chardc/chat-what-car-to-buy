"""
Retriever logic:
1. Embed the expanded query with prepended prompt

2. Search for semantically similar submissions or submission chunks from
the vector store based on the embedded query.

3. Index the relevant comment embeddings belonging to the chosen document chunks, then
retrieve the closest match to the embedded query.

4. Modify the user prompt to include the retrieved references.
"""

from fileinput import filename
import logging
import pandas as pd
from pandas.tests.tslibs.test_liboffsets import get_lastbday
from usedcaranalytics.utils.getpath import get_path, get_latest_path
from usedcaranalytics.rag.prep import prepare_and_export_data
from usedcaranalytics.rag.embeddings import build_embedding_model
from usedcaranalytics.rag.documents import chunks_from_pandas
from usedcaranalytics.config.logging_config import setup_logging


def parse_latest_data(search_pat: str):
    """
    Parse the most recent parquet files generated by the prepare_data.py script (Merging raw
    parquet files, wrangling, and exporting to data/processed/partition directory).
    
    Args:
        search_pat: PosixPath search pattern.
        
    Returns:
        dataframe: Pandas DataFrame for submissions or comments.
    """
    return pd.read_parquet(path=get_latest_path(search_pat), engine='pyarrow')

def main():    
    # Merge and wrangle latest scraped data then save to disk
    prepare_and_export_data()
    
    # Parse latest processed data
    submissions = parse_latest_data('data/processed/*/submissions.parquet')
    comments = parse_latest_data('data/processed/*/submissions.parquet')
    
    # Build the embedding model
    emb_model = build_embedding_model(device='mps', batch_size=256, normalize_embeddings=True, show_progress=True)
    
    # Chunk texts to ensure it stays within SBERT context window (256 tokens)
    submission_docs = chunks_from_pandas(submissions)
    comment_docs = chunks_from_pandas(comments)
    
    # Create the vector stores
    raise NotImplementedError('Vector stores to be implemented')

if __name__ == '__main__':
    setup_logging(level=logging.DEBUG, output_to_console=True)
    main()